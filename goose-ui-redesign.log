starting session | provider: anthropic lead model: claude-opus-4-6 worker model: claude-opus-4-6
    session id: 20260213_7
    working directory: /Users/ariya/Projects/OpenClawToggle


I'll start by reading all source files to understand the current codebase structure.
─── analyze | developer ──────────────────────────
max_depth: 5
path: /Users/ariya/Projects/OpenClawToggle


─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/OpenClawToggleApp.swift
command: view


─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/PopoverView.swift
command: view


─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/StatusMonitor.swift
command: view


─── text_editor | developer ──────────────────────────
path: ~/Projects/OpenClawToggle/Package.swift
command: view

Now let me check the Resources directory for the icon:
─── shell | developer ──────────────────────────
command: ls -la ~/Projects/OpenClawToggle/Resources/ 2>/dev/null; echo "---"; ls -la ~/Projects/OpenClawToggle/OpenClawToggle.app/Contents/Resources/ 2>/dev/null; echo "---"; find ~/Projects/OpenClawToggle -name "alfred-icon.png" 2>/dev/null

Now let me set up the TODO and then implement all three files:
─── todo_write | todo ──────────────────────────
content: # OpenClawToggle UI Redesign

- [ ] Rewrite StatusMonitor.swift
  - [ ] Add tunnelRunning published state
  - [ ] Add tunnelServiceLoaded state
  - [ ] Add toggleTunnel() method (bootout/bootstrap for ssh-tunnel)
  - [ ] Add isTunnelToggling state
  - [ ] Keep 5-second polling
- [ ] Rewrite OpenClawToggleApp.swift (MenuBarIcon)
  - [ ] Circular clipped avatar (18x18)
  - [ ] Instagram-style green ring when connected
  - [ ] Yellow ring when tunnel only
  - [ ] No ring + dimmed when disconnected
  - [ ] Ring: ~2px thick with gap between image and ring
  - [ ] isTemplate = false
- [ ] Rewrite PopoverView.swift
  - [ ] Header: large circular avatar (~40px) with status ring + status text
  - [ ] Controls: two toggle rows (Node Service / SSH Tunnel) with label, dot, toggle button
  - [ ] Node toggle: bootout to stop, bootstrap to start
  - [ ] Tunnel toggle: bootout to stop, bootstrap to start
  - [ ] Quit: small subtle text button, right-aligned, muted
  - [ ] Clean styling: 280px width, proper fonts, dividers, spacing
- [ ] swift build
- [ ] Copy binary to OpenClawToggle.app/Contents/MacOS/
- [ ] Git commit


I have a complete understanding of the codebase. Now I'll implement all three files. Let me do them all at once:
─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/StatusMonitor.swift
command: write
file_text: // SPDX-License-Identifier: MIT
// OpenClaw Toggle — macOS menu bar app for OpenClaw node management.

import SwiftUI

// ---------------------------------------------------------------------------
// MARK: - Connection State
// ---------------------------------------------------------------------------

/// Represents the aggregate health of the OpenClaw stack.
enum ConnectionState: String {
    case connected    = "Connected"      // tunnel + node both running
    case tunnelOnly   = "Tunnel Only"    // tunnel alive, node stopped
    case disconnected = "Disconnected"   // neither running

    /// SF Symbol color shown in the menu bar and status dot.
    var color: Color {
        switch self {
        case .connected:    return .green
        case .tunnelOnly:   return .yellow
        case .disconnected: return .red
        }
    }
}

// ---------------------------------------------------------------------------
// MARK: - Status Monitor
// ---------------------------------------------------------------------------

/// Polls system state every few seconds and publishes the results so SwiftUI
/// views stay in sync automatically.
@MainActor
final class StatusMonitor: ObservableObject {

    // MARK: Published state

    @Published private(set) var tunnelActive: Bool = false
    @Published private(set) var nodeRunning: Bool  = false
    @Published private(set) var state: ConnectionState = .disconnected
    @Published private(set) var isToggling: Bool = false
    @Published private(set) var isTunnelToggling: Bool = false

    /// Tracks whether the launchd node service is loaded (bootstrapped).
    @Published private(set) var serviceLoaded: Bool = true

    /// Tracks whether the launchd tunnel service is loaded (bootstrapped).
    @Published private(set) var tunnelServiceLoaded: Bool = true

    // MARK: Configuration

    /// Local port used by the SSH tunnel.
    private let tunnelPort: UInt16 = 18789

    /// Launchd service label for the OpenClaw node.
    private let nodeServiceLabel = "ai.openclaw.node"

    /// Launchd service label for the SSH tunnel.
    private let tunnelServiceLabel = "ai.openclaw.ssh-tunnel"

    /// How often (in seconds) to refresh status.
    private let pollInterval: TimeInterval = 5

    /// The current user's UID (used in launchctl gui/<uid>/… paths).
    private let uid: String = {
        ProcessInfo.processInfo.environment["SUDO_UID"]
            ?? String(getuid())
    }()

    /// Path to the node LaunchAgent plist.
    private var nodePlistPath: String {
        NSHomeDirectory() + "/Library/LaunchAgents/\(nodeServiceLabel).plist"
    }

    /// Path to the tunnel LaunchAgent plist.
    private var tunnelPlistPath: String {
        NSHomeDirectory() + "/Library/LaunchAgents/\(tunnelServiceLabel).plist"
    }

    private var pollTask: Task<Void, Never>?

    // MARK: Lifecycle

    func startPolling() {
        stopPolling()
        pollTask = Task { [weak self] in
            guard let self else { return }
            while !Task.isCancelled {
                await self.refresh()
                try? await Task.sleep(for: .seconds(self.pollInterval))
            }
        }
    }

    func stopPolling() {
        pollTask?.cancel()
        pollTask = nil
    }

    // MARK: Refresh

    /// Runs both checks concurrently, then derives the aggregate state.
    func refresh() async {
        async let tunnel = checkTunnel()
        async let node   = checkNode()

        let (t, n) = await (tunnel, node)
        tunnelActive = t
        nodeRunning  = n

        switch (t, n) {
        case (true, true):   state = .connected
        case (true, false):  state = .tunnelOnly
        default:             state = .disconnected
        }
    }

    // MARK: Toggle Node

    /// Start or stop the launchd node service.
    func toggleNode() async {
        guard !isToggling else { return }
        isToggling = true
        defer { isToggling = false }

        if nodeRunning || serviceLoaded {
            await runShell("/bin/launchctl", arguments: [
                "bootout", "gui/\(uid)/\(nodeServiceLabel)"
            ])
            serviceLoaded = false
        } else {
            await runShell("/bin/launchctl", arguments: [
                "bootstrap", "gui/\(uid)", nodePlistPath
            ])
            serviceLoaded = true
        }

        try? await Task.sleep(for: .milliseconds(800))
        await refresh()
    }

    // MARK: Toggle Tunnel

    /// Start or stop the launchd SSH tunnel service.
    func toggleTunnel() async {
        guard !isTunnelToggling else { return }
        isTunnelToggling = true
        defer { isTunnelToggling = false }

        if tunnelActive || tunnelServiceLoaded {
            await runShell("/bin/launchctl", arguments: [
                "bootout", "gui/\(uid)/\(tunnelServiceLabel)"
            ])
            tunnelServiceLoaded = false
        } else {
            await runShell("/bin/launchctl", arguments: [
                "bootstrap", "gui/\(uid)", tunnelPlistPath
            ])
            tunnelServiceLoaded = true
        }

        try? await Task.sleep(for: .milliseconds(800))
        await refresh()
    }

    // MARK: - Private helpers

    /// Returns `true` when something is listening on `tunnelPort`.
    private func checkTunnel() async -> Bool {
        let output = await runShell(
            "/usr/sbin/lsof",
            arguments: ["-iTCP:\(tunnelPort)", "-sTCP:LISTEN", "-P", "-n"]
        )
        let active = !output.isEmpty

        // Also check if the tunnel service is loaded in launchd.
        let svcOutput = await runShell(
            "/bin/launchctl",
            arguments: ["print", "gui/\(uid)/\(tunnelServiceLabel)"]
        )
        let svcLines = svcOutput.lowercased()
        if svcLines.contains("could not find service") || svcOutput.isEmpty {
            tunnelServiceLoaded = false
        } else {
            tunnelServiceLoaded = true
        }

        return active
    }

    /// Returns `true` when the launchd service has a running PID.
    /// Also updates `serviceLoaded` based on whether the service exists.
    private func checkNode() async -> Bool {
        let output = await runShell(
            "/bin/launchctl", arguments: ["print", "gui/\(uid)/\(nodeServiceLabel)"]
        )

        let lines = output.lowercased()

        if lines.contains("could not find service") || output.isEmpty {
            serviceLoaded = false
            return false
        }

        serviceLoaded = true

        if lines.contains("state = running") { return true }

        if let range = lines.range(of: "pid = ") {
            let after = lines[range.upperBound...]
            let digits = after.prefix(while: { $0.isNumber })
            if let pid = Int(digits), pid > 0 { return true }
        }
        return false
    }

    /// Runs a command and returns its trimmed stdout (ignoring failures).
    @discardableResult
    private func runShell(_ path: String, arguments: [String]) async -> String {
        await withCheckedContinuation { continuation in
            DispatchQueue.global(qos: .utility).async {
                let process = Process()
                let pipe = Pipe()
                process.executableURL = URL(fileURLWithPath: path)
                process.arguments = arguments
                process.standardOutput = pipe
                process.standardError = FileHandle.nullDevice
                do {
                    try process.run()
                    process.waitUntilExit()
                } catch {
                    continuation.resume(returning: "")
                    return
                }
                let data = pipe.fileHandleForReading.readDataToEndOfFile()
                let output = String(data: data, encoding: .utf8)?
                    .trimmingCharacters(in: .whitespacesAndNewlines) ?? ""
                continuation.resume(returning: output)
            }
        }
    }
}



─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/OpenClawToggleApp.swift
command: write
file_text: // SPDX-License-Identifier: MIT
// OpenClaw Toggle — main app entry point.
//
// A menu-bar-only macOS app that monitors and controls the OpenClaw node
// service.  No Dock icon is shown (controlled via NSApp.setActivationPolicy).

import AppKit
import Combine
import SwiftUI

// ---------------------------------------------------------------------------
// MARK: - App Delegate
// ---------------------------------------------------------------------------

/// Owns the `NSStatusItem` and the menu.  Uses NSMenu with a custom
/// NSMenuItem containing an NSHostingView instead of NSPopover, which
/// eliminates the common gap-below-menu-bar-icon issue on macOS.
@MainActor
final class AppDelegate: NSObject, NSApplicationDelegate, NSMenuDelegate {

    private var statusItem: NSStatusItem!
    private let monitor = StatusMonitor()
    private var cancellables = Set<AnyCancellable>()

    /// The menu shown when the status item is clicked.
    private let menu = NSMenu()

    /// The hosting view inside the custom menu item.
    private var hostingView: NSHostingView<PopoverView>?

    // MARK: NSApplicationDelegate

    func applicationDidFinishLaunching(_ notification: Notification) {
        // Hide dock icon programmatically as a safety net
        // (Info.plist LSUIElement is the primary mechanism when bundled).
        NSApp.setActivationPolicy(.accessory)
        // Prevent macOS from automatically terminating this menu bar app
        ProcessInfo.processInfo.disableAutomaticTermination("Menu bar app must stay alive")
        ProcessInfo.processInfo.disableSuddenTermination()

        // ── Status bar item ───────────────────────────────────────────
        statusItem = NSStatusBar.system.statusItem(
            withLength: NSStatusItem.variableLength
        )
        if let button = statusItem.button {
            button.image = MenuBarIcon.create(for: .disconnected)
            button.image?.isTemplate = false
        }

        // ── Menu with custom view ─────────────────────────────────────
        let contentView = PopoverView(monitor: monitor)
        let hostingView = NSHostingView(rootView: contentView)
        // Let the hosting view determine its ideal size.
        hostingView.setFrameSize(hostingView.fittingSize)
        self.hostingView = hostingView

        let menuItem = NSMenuItem()
        menuItem.view = hostingView
        menu.addItem(menuItem)
        menu.delegate = self

        statusItem.menu = menu

        // ── React to state changes ────────────────────────────────────
        monitor.$state
            .receive(on: DispatchQueue.main)
            .sink { [weak self] state in
                self?.updateIcon(for: state)
            }
            .store(in: &cancellables)

        // ── Start polling ─────────────────────────────────────────────
        monitor.startPolling()
    }

    func applicationWillTerminate(_ notification: Notification) {
        monitor.stopPolling()
    }

    // MARK: NSMenuDelegate

    func menuWillOpen(_ menu: NSMenu) {
        // Resize the hosting view each time the menu opens to pick up
        // any content size changes from SwiftUI.
        hostingView?.setFrameSize(hostingView?.fittingSize ?? .zero)
    }

    // MARK: Icon update

    private func updateIcon(for state: ConnectionState) {
        statusItem.button?.image = MenuBarIcon.create(for: state)
        statusItem.button?.image?.isTemplate = false
    }
}

// ---------------------------------------------------------------------------
// MARK: - Menu Bar Icon (Instagram Close Friends style)
// ---------------------------------------------------------------------------

/// Creates a composited menu bar icon: alfred-icon.png clipped to a circle
/// with an Instagram Close Friends style ring around it.
///
/// - Connected (tunnel + node): bright green ring
/// - Tunnel Only: yellow ring
/// - Disconnected: no ring, avatar slightly dimmed
enum MenuBarIcon {
    /// Total canvas size for the menu bar icon.
    static let size = NSSize(width: 22, height: 22)

    /// Cached base icon loaded once from disk.
    private static let baseIcon: NSImage? = {
        // Try the app bundle first (works when running as OpenClawToggle.app)
        let bundlePath = Bundle.main.bundlePath
            + "/Contents/Resources/alfred-icon.png"
        if let img = NSImage(contentsOfFile: bundlePath) {
            return img
        }
        // Fallback: load from the source tree directly
        let fallbackPath = NSString(
            string: "~/Projects/OpenClawToggle/Resources/alfred-icon.png"
        ).expandingTildeInPath
        return NSImage(contentsOfFile: fallbackPath)
    }()

    static func create(for state: ConnectionState) -> NSImage {
        let img = NSImage(size: size, flipped: false) { rect in

            let center = NSPoint(x: rect.midX, y: rect.midY)

            // Layout constants
            let ringLineWidth: CGFloat = 2.0
            let gapWidth: CGFloat = 1.5
            let ringOuterRadius: CGFloat = min(rect.width, rect.height) / 2.0
            let ringCenterRadius = ringOuterRadius - ringLineWidth / 2.0
            let avatarRadius = ringOuterRadius - ringLineWidth - gapWidth

            // ── Draw ring (if not disconnected) ──────────────────────
            if state != .disconnected {
                let ringColor: NSColor = switch state {
                case .connected:  .systemGreen
                case .tunnelOnly: .systemYellow
                case .disconnected: .clear  // won't reach
                }
                ringColor.setStroke()
                let ringPath = NSBezierPath()
                ringPath.appendArc(
                    withCenter: center,
                    radius: ringCenterRadius,
                    startAngle: 0,
                    endAngle: 360
                )
                ringPath.lineWidth = ringLineWidth
                ringPath.stroke()
            }

            // ── Clip & draw circular avatar ──────────────────────────
            let avatarDiameter = avatarRadius * 2
            let avatarRect = NSRect(
                x: center.x - avatarRadius,
                y: center.y - avatarRadius,
                width: avatarDiameter,
                height: avatarDiameter
            )

            if let base = baseIcon {
                NSGraphicsContext.saveGraphicsState()
                let clipPath = NSBezierPath(ovalIn: avatarRect)
                clipPath.addClip()
                base.draw(
                    in: avatarRect,
                    from: NSRect(origin: .zero, size: base.size),
                    operation: .sourceOver,
                    fraction: state == .disconnected ? 0.45 : 1.0
                )
                NSGraphicsContext.restoreGraphicsState()
            }

            return true
        }
        img.isTemplate = false
        return img
    }
}

// ---------------------------------------------------------------------------
// MARK: - Entry point
// ---------------------------------------------------------------------------

/// Minimal `@main` struct to bootstrap the NSApplication run loop.
/// We use this instead of bare top-level code because SPM executable targets
/// with multiple source files don't allow top-level expressions.
@main
struct OpenClawToggleEntry {
    static func main() {
        let app = NSApplication.shared
        let delegate = AppDelegate()
        app.delegate = delegate
        app.run()
    }
}



─── text_editor | developer ──────────────────────────
path: ~/P/O/S/OpenClawToggle/PopoverView.swift
command: write
file_text: // SPDX-License-Identifier: MIT
// OpenClaw Toggle — popover view shown when the menu bar icon is clicked.

import SwiftUI

/// The small popover UI displayed from the menu bar icon.
/// Clean, minimal macOS-native design with Instagram-style status ring avatar.
struct PopoverView: View {
    @ObservedObject var monitor: StatusMonitor

    var body: some View {
        VStack(spacing: 0) {

            // ── Header: Avatar + Status ──────────────────────────────
            headerSection
                .padding(.horizontal, 16)
                .padding(.top, 16)
                .padding(.bottom, 12)

            Divider()
                .padding(.horizontal, 12)

            // ── Controls ─────────────────────────────────────────────
            VStack(spacing: 0) {
                serviceRow(
                    label: "SSH Tunnel",
                    isActive: monitor.tunnelActive,
                    isLoaded: monitor.tunnelServiceLoaded,
                    isToggling: monitor.isTunnelToggling,
                    action: { Task { await monitor.toggleTunnel() } }
                )

                Divider()
                    .padding(.horizontal, 12)

                serviceRow(
                    label: "Node Service",
                    isActive: monitor.nodeRunning,
                    isLoaded: monitor.serviceLoaded,
                    isToggling: monitor.isToggling,
                    action: { Task { await monitor.toggleNode() } }
                )
            }
            .padding(.vertical, 4)

            Divider()
                .padding(.horizontal, 12)

            // ── Quit ─────────────────────────────────────────────────
            HStack {
                Spacer()
                Button("Quit") {
                    NSApplication.shared.terminate(nil)
                }
                .buttonStyle(.plain)
                .font(.caption)
                .foregroundStyle(.tertiary)
                .padding(.trailing, 16)
                .padding(.vertical, 10)
            }
        }
        .frame(width: 280)
    }

    // MARK: - Header

    private var headerSection: some View {
        HStack(spacing: 12) {
            // Instagram-style circular avatar with status ring
            AvatarRingView(state: monitor.state, diameter: 40)

            VStack(alignment: .leading, spacing: 2) {
                Text(monitor.state.rawValue)
                    .font(.headline)
                    .foregroundStyle(monitor.state == .disconnected ? .secondary : .primary)

                Text(statusSubtitle)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }

            Spacer()
        }
    }

    private var statusSubtitle: String {
        switch monitor.state {
        case .connected:    return "All systems operational"
        case .tunnelOnly:   return "Node service is down"
        case .disconnected: return "All services stopped"
        }
    }

    // MARK: - Service Row

    private func serviceRow(
        label: String,
        isActive: Bool,
        isLoaded: Bool,
        isToggling: Bool,
        action: @escaping () -> Void
    ) -> some View {
        HStack(spacing: 10) {
            // Status dot
            Circle()
                .fill(isActive ? Color.green : Color.red.opacity(0.7))
                .frame(width: 7, height: 7)

            // Label
            Text(label)
                .font(.subheadline)

            Spacer()

            // Toggle button
            if isToggling {
                ProgressView()
                    .controlSize(.small)
                    .frame(width: 52, height: 22)
            } else {
                Button(isActive || isLoaded ? "Stop" : "Start") {
                    action()
                }
                .buttonStyle(ServiceButtonStyle(isActive: isActive || isLoaded))
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 10)
    }
}

// ---------------------------------------------------------------------------
// MARK: - Avatar Ring View (Instagram Close Friends style)
// ---------------------------------------------------------------------------

/// Draws a circular avatar with an optional Instagram-style ring.
/// Used in both the popover header and could be reused elsewhere.
private struct AvatarRingView: View {
    let state: ConnectionState
    let diameter: CGFloat

    /// Ring thickness as proportion of diameter
    private var ringWidth: CGFloat { max(2.0, diameter * 0.06) }
    /// Gap between ring and avatar
    private var gap: CGFloat { max(1.5, diameter * 0.04) }
    /// Avatar diameter after subtracting ring + gap
    private var avatarDiameter: CGFloat {
        diameter - (ringWidth + gap) * 2
    }

    var body: some View {
        ZStack {
            // Ring (only when not disconnected)
            if state != .disconnected {
                Circle()
                    .stroke(ringColor, lineWidth: ringWidth)
                    .frame(width: diameter, height: diameter)
            }

            // Circular avatar
            AlfredAvatarImage(diameter: avatarDiameter, dimmed: state == .disconnected)
        }
        .frame(width: diameter, height: diameter)
    }

    private var ringColor: Color {
        switch state {
        case .connected:    return .green
        case .tunnelOnly:   return .yellow
        case .disconnected: return .clear
        }
    }
}

// ---------------------------------------------------------------------------
// MARK: - Alfred Avatar Image
// ---------------------------------------------------------------------------

/// Loads the Alfred icon from disk and displays it clipped to a circle.
private struct AlfredAvatarImage: View {
    let diameter: CGFloat
    let dimmed: Bool

    private static let image: NSImage? = {
        let bundlePath = Bundle.main.bundlePath
            + "/Contents/Resources/alfred-icon.png"
        if let img = NSImage(contentsOfFile: bundlePath) { return img }
        let fallback = NSString(
            string: "~/Projects/OpenClawToggle/Resources/alfred-icon.png"
        ).expandingTildeInPath
        return NSImage(contentsOfFile: fallback)
    }()

    var body: some View {
        Group {
            if let nsImage = Self.image {
                Image(nsImage: nsImage)
                    .resizable()
                    .scaledToFill()
                    .frame(width: diameter, height: diameter)
                    .clipShape(Circle())
                    .opacity(dimmed ? 0.45 : 1.0)
            } else {
                Circle()
                    .fill(.quaternary)
                    .frame(width: diameter, height: diameter)
            }
        }
    }
}

// ---------------------------------------------------------------------------
// MARK: - Service Button Style
// ---------------------------------------------------------------------------

/// A clean, minimal button style for start/stop service controls.
private struct ServiceButtonStyle: ButtonStyle {
    let isActive: Bool

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(.caption.weight(.medium))
            .foregroundStyle(isActive ? .red : .green)
            .padding(.horizontal, 12)
            .padding(.vertical, 4)
            .background(
                RoundedRectangle(cornerRadius: 6)
                    .fill(isActive
                        ? Color.red.opacity(0.1)
                        : Color.green.opacity(0.1))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 6)
                    .stroke(isActive
                        ? Color.red.opacity(0.25)
                        : Color.green.opacity(0.25),
                        lineWidth: 0.5)
            )
            .opacity(configuration.isPressed ? 0.7 : 1.0)
    }
}


All three files are written. Now let's build:
─── shell | developer ──────────────────────────
command: cd ~/Projects/OpenClawToggle && swift build 2>&1

Build successful. Now copy the binary and commit:
─── shell | developer ──────────────────────────
command: cd ~/Projects/OpenClawToggle && cp .build/debug/OpenClawToggle OpenClawToggle.app/Contents/MacOS/OpenClawToggle && echo "Binary copied successfully"


─── shell | developer ──────────────────────────
command: cd ~/Projects/OpenClawToggle && git add -A && git commit -m "Major UI redesign: Instagram Close Friends style status ring + clean popover

Menu Bar Icon:
- Alfred avatar clipped to circle (22x22 canvas)
- Instagram-style green ring when connected (tunnel + node)
- Yellow ring when tunnel only
- No ring + dimmed avatar when disconnected
- 2px ring with 1.5px gap between ring and avatar

Popover UI:
- Header with 40px circular avatar + status ring + status text/subtitle
- Two separate service rows (SSH Tunnel / Node Service)
- Each row has status dot, label, and Start/Stop button
- Clean ServiceButtonStyle with colored backgrounds and borders
- Subtle right-aligned Quit button
- 280px width, proper spacing and dividers

StatusMonitor:
- Added toggleTunnel() method for SSH tunnel service control
- Added tunnelServiceLoaded and isTunnelToggling published state
- Tunnel uses ai.openclaw.ssh-tunnel launchd service label
- checkTunnel() now also checks launchd service loaded state
- Kept 5-second polling interval" 2>&1

Now let me update the TODO:
─── todo_write | todo ──────────────────────────
content: # OpenClawToggle UI Redesign

- [x] Rewrite StatusMonitor.swift
  - [x] Add tunnelRunning / tunnelServiceLoaded published state
  - [x] Add toggleTunnel() method (bootout/bootstrap for ssh-tunnel)
  - [x] Add isTunnelToggling state
  - [x] Keep 5-second polling
- [x] Rewrite OpenClawToggleApp.swift (MenuBarIcon)
  - [x] Circular clipped avatar (22x22 canvas)
  - [x] Instagram-style green ring when connected
  - [x] Yellow ring when tunnel only
  - [x] No ring + dimmed (0.45 opacity) when disconnected
  - [x] Ring: 2px thick with 1.5px gap
  - [x] isTemplate = false
- [x] Rewrite PopoverView.swift
  - [x] Header: 40px circular avatar with status ring + status text + subtitle
  - [x] Controls: two toggle rows (SSH Tunnel / Node Service) with dot, label, Start/Stop button
  - [x] ServiceButtonStyle with colored backgrounds
  - [x] Quit: subtle right-aligned caption text button
  - [x] Clean styling: 280px width, proper fonts, dividers, spacing
- [x] swift build ✅ (0.73s)
- [x] Copy binary to OpenClawToggle.app/Contents/MacOS/
- [x] Git commit (b73cef9)


All done! Here's a summary of everything that was implemented:

---

## ✅ UI Redesign Complete

### Menu Bar Icon — Instagram Close Friends Style
- **22×22 canvas** with the Alfred icon **clipped to a circle**
- **Connected** (tunnel + node): bright **green ring** around avatar
- **Tunnel Only**: **yellow ring** around avatar
- **Disconnected**: **no ring**, avatar dimmed to 45% opacity
- Ring is **2px thick** with a **1.5px gap** between ring and avatar image
- `isTemplate = false` on all generated images

### Popover — Clean & Minimal
- **Header**: 40px circular avatar with Instagram-style status ring + status headline + contextual subtitle ("All systems operational" / "Node service is down" / "All services stopped")
- **Two service rows**: SSH Tunnel and Node Service, each with:
  - Color-coded status dot (green/red)
  - Service label
  - **Start/Stop button** with custom `ServiceButtonStyle` (green tint for Start, red tint for Stop, rounded corners, subtle border)
- **Quit**: small, right-aligned, tertiary-color caption button — very unobtrusive
- **280px** width with proper padding, dividers, and spacing

### StatusMonitor — New Tunnel Controls
- **`toggleTunnel()`** method: `launchctl bootout gui/501/ai.openclaw.ssh-tunnel` to stop, `launchctl bootstrap gui/501 ~/Library/LaunchAgents/ai.openclaw.ssh-tunnel.plist` to start
- New published state: `tunnelServiceLoaded`, `isTunnelToggling`
- `checkTunnel()` now also queries launchd to track whether the tunnel service is loaded
- 5-second polling preserved

### Build & Deploy
- `swift build` — ✅ compiled in 0.73s
- Binary copied to `OpenClawToggle.app/Contents/MacOS/`
- Committed as `b73cef9`
DONE
